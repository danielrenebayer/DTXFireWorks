/*
 * units.h
 *
 * It contains the definition of all units. A unit is
 * a compositions of individual components, that might
 * has more complex control rules or the additionl data
 * input.
 *
 */

#ifndef UNITS_H
#define UNITS_H

#include <string>
#include <list>
#include <map>

// The following classes are defined in this header file:
class Substation;
class ControlUnit;
class MeasurementUnit;
class OpenSpacePVOrWind;

#include "global.h"
#include "components.h"
#include "output.h"


/*!
 * This class represents a substation.
 * One or more control units are connected to one instance of this class.
 */
class Substation {
    public:
        static Substation* InstantiateNewSubstation(unsigned long id, std::string* name) {
            return new Substation(id, name);
        }
    private:
        Substation(unsigned long id, std::string* name);
    public:
        ~Substation();
        // getter methods
        unsigned long get_id() { return id; }
        const std::string * get_name() { return name; }
        float get_station_load()       const { return station_load;    } ///< Returns the current load at the substation in kW
        float get_residential_load()   const { return resident_load;   } ///< Returns the current load at the substation in kW, generated by residential control units only
        float get_residential_demand() const { return resident_demand; } ///< Returns the demand of residential control units at this substation in kW
        // modifiers bevore simulation start
        void add_unit(ControlUnit* unit);
        // methods for simulation run
        void  calc_load();
        const std::list<ControlUnit*>* get_connected_units() { return connected_units; } ///< Return the list of connected units (as read only list)
        //
        // static functions
        // 1. Initializers and destructors
        static void InitializeStaticVariables(unsigned long n_substations);
        static void VacuumInstancesAndStaticVariables();
        // 2. getter functions
        static inline Substation* GetInstance(unsigned long id);
        static        Substation*const * GetArrayOfInstances() {return st__substation_list;}
        static        size_t GetNumberOfInstances() {return st__n_substations;}
    private:
        // constant member variables (other languages might call this 'final')
        const unsigned long id;
        const std::string *const name;
        // member variables that can change over time
        std::list<ControlUnit*>* connected_units;
        float station_load;    ///< Load of the station
        float resident_load;   ///< Load only of residential buildings
        float resident_demand; ///< Residential load, only demand
        //
        // static list of substations
        static bool st__substation_list_init;
        static unsigned long st__n_substations;
        static unsigned long st__new_substation_position;
        static Substation** st__substation_list;
};


/*!
 * This class represents a control unit (i.e. a private house or a small company).
 * As the name suggests it is the place where a central control is located (if any, or a rulebased otherwise).
 * All simulatively added components are added in this control unit.
 * It holds a set (at least one) of measurement units.
 */
class ControlUnit {
    public:
        static ControlUnit* InstantiateNewControlUnit(unsigned long unitID, unsigned long substation_id, unsigned long locationID, bool residential) {
            return new ControlUnit(unitID, substation_id, locationID, residential);
        }
    private:
        ControlUnit(unsigned long unitID, unsigned long substation_id, unsigned long locationID, bool residential);
    public:
        ~ControlUnit();
        void add_unit(MeasurementUnit* unit);
        bool has_electricity_demand();
        bool has_pv();
        bool has_bs();
        bool has_hp();
        bool has_cs(); ///< Checks, if the unit has an EV charging station connected (in data or simulated)
        bool has_chp();
        bool has_bs_sim_added();
        bool is_expandable_with_pv_hp(); ///< Is a PV installation or a heat pump addable (yes, if geodata is available). This function uses caching.
        bool is_residential() { return residential; } ///< Is this unit a residential unit?
        int  get_exp_combi_bit_repr();
        int  get_exp_combi_bit_repr_from_MUs();
        int  get_exp_combi_bit_repr_sim_added();
        float get_current_load_vSMeter_kW() { return current_load_vSM_kW; }
        size_t get_n_MUs()     { return connected_units->size(); } // returns the number of MUs, that are connected to the given control unit
        size_t get_unitID()    { return unitID; } // returns the unit ID of this control unit
        float get_sim_comp_pv_kWp(); // returns the kWp of the PV-component that is added for the simulation, returns 0 if there is no added PV component
        float get_sim_comp_bs_P_kW(); // returns the power in kW of the battery storage component that is added for the simulation, returns 0 if there is no added battery
        float get_sim_comp_bs_E_kWh(); // returns the capacity in kWh of the battery storage component that is added for the simulation, returns 0 if there is no added battery
        float get_annual_hp_el_cons(); ///< Returns the annual HP electricity consumption of a heat pump, if it would be added simulatively (regardless whether it is added or not)
        float get_sim_comp_cs_max_P_kW() const; ///< Returns the maximum available charging power of the simulatively added charging station (if the station is enabled; otherwise it returns 0)
        size_t get_sim_comp_cs_n_EVs() const;   ///< Returns the number of connected EVs if the charging station component is enabled, otherwise 0 is returned.
        size_t get_sim_comp_cs_possible_n_EVs() const; ///< Returns the number of EVs that would be connected to the charging station component, if it would be enablede
        double  get_SSR(); ///< Returns the SSR of the CU from the start of the simulation run until the time of function call; most usefull at the end of a simulation run
        double  get_SCR(); ///< Returns the SCR of the CU from the start of the simulation run until the time of function call; most usefull at the end of a simulation run
        double  get_NPV(); ///< Returns the net present value (NPV) of the CU from the start of the simulation run until the time of function call; most usefull at the end of a simulation run
        string* get_metrics_string_annual(); // call this function only if simulation run is finished! It will the compute sums of flows,SSC,SSR and output this as a string
        string* get_metrics_string_weekly_wr(unsigned long week_number); // This function outputs the weekly metrics AND resets the internal weekly counters!
        string* get_pv_section_string(); // This function returns a string containing information about the sections of the sim. added PV component. If no PV component is added, it returns an empty string.
        // public members
        bool is_sim_expanded; ///< Puplicly accessible member, weather the control unit is expanded or not (required for SAC Planning). This flag has no internal effect inside the class.
        // modifiers
        void add_exp_pv();
        void add_exp_bs();
        void add_exp_hp();
        void add_exp_cs(); ///< Activates / enables the EV charging station at the control unit
        void add_ev(unsigned long carID); ///< Adds an EV to the charging station (regardless if the charging station is enabled or not)
        void set_output_object(CUOutput* output_obj);
        void set_exp_pv_params_A(float kWp_static); ///< Set the kWp of expanded PV installations in the case of static kWp computation per section
        void set_exp_pv_params_B(float kWp_per_m2, float min_kWp, float max_kWp); ///< Set the kWp of expanded PV installations in the case of dynamic kWp computation per section
        void set_exp_bs_maxE_kWh(float value);
        void set_exp_bs_maxP_kW (float value);
        void set_exp_bs_E_P_ratio(float value); //< Set the E:P-ratio for simulatively added BS components to @param value
        void remove_sim_added_pv(); ///< Removes a simulatively added PV installation
        void remove_sim_added_bs(); ///< Removes a simulatively added battery storage
        void remove_sim_added_components(); ///< Remove all components that are added simulatively
        void reset_internal_state(); ///< Resets the internal state of the object, without removing added components
        // for simulation runs
        bool compute_next_value(unsigned long ts, unsigned int dayOfWeek_l, unsigned int hourOfDay_l); ///< Computes the value for the (next) time step. The additional parameters dayOfWeek and hourOfDay are only required for passing them to the Charging Station. Mind: Both values are "left-aligned", i.e., they are the labels for the start of the current time step (in contrast to global::time_localtime_str)
        //
        // static functions
        // 1. Initializers and destructors
        static void InitializeStaticVariables(unsigned long n_CUs);
        static void VacuumInstancesAndStaticVariables();
        // 2. getter functions
        static ControlUnit* GetInstance(unsigned long unitID);   ///< Returns instance with unitID or NULL, if unitID is out of the given range
        static ControlUnit* GetInstanceWE(unsigned long unitID); ///< Returns instance with unitID or throws an error, if untiID is not defined
        //static ControlUnit* GetInstanceAtLocationID(unsigned long locationID);
        static ControlUnit*const * GetArrayOfInstances() {return st__cu_list;}
        static size_t GetNumberOfInstances() {return st__n_CUs;}
        static size_t GetNumberOfCUsWithSimCompPV();        ///< Returns the number of control units that hold a simulatively added PV installation
        static size_t GetNumberOfCUsWithSimCompHP();        ///< Returns the number of control units that hold a simulatively added heat pump
        static size_t GetNumberOfCUsWithSimCompEV();        ///< Returns the number of control units that hold a simulatively added (private) EV charging stations
        static double GetAllSimCompBatteriesCharge_kWh();   ///< Returns the charge of all simulatively added battery storage systems at the current ts
        static double GetAllSimCompBatteriesCapacity_kWh(); ///< Returns the capacity of all simulatively added battery storage systems
        // 3. modifiers for all created objects
        static void ResetAllInternalStates();
        static void RemoveAllSimAddedComponents(); ///< Removes all simulatively added components from all control units
    private:
        // constant member variables (other languages might call this 'final')
        const unsigned long unitID;
        Substation *const higher_level_subst;
        const unsigned long locationID;
        const bool residential; ///< is this control unit representing a residential unit?
        // member variables that can change over time
        std::list<MeasurementUnit*>* connected_units;
        bool has_sim_pv; ///< boolean variable that states if a PV installation is simulatively added
        bool has_sim_bs; ///< boolean variable that states if a battery storage is simulatively added
        bool has_sim_hp; ///< boolean variable that states if a heap pump is simulatively added
        bool has_sim_cs; ///< boolean variable that states if an EV charging station is simulatively added
        ComponentPV* sim_comp_pv; ///< Reference to the simulated PV-Component (if it exists)
        ComponentBS* sim_comp_bs; ///< Reference to the simulated battery storage component (if it exists)
        ComponentHP* sim_comp_hp; ///< Reference to the simulated Heat Pump Component (if it exists)
        ComponentCS* sim_comp_cs; ///< Reference to the simulated EV charging station Component (if it exists)
        CUOutput*    output_obj;
        // summation variables from the beginning of the simulation run until the current time step
        double sum_of_consumption_kWh;    ///< The sum of consumed energy in kWh starting from the beginning of the current simulation run
        double sum_of_self_cons_kWh;      ///< The sum of self-consumed energy in kWh starting from the beginning of the current simulation run
        double sum_of_mu_cons_kWh;        ///< The sum of energy consumed by measurement units from the beginning fo the simulation until the current step
        double sum_of_feed_into_grid_kWh; ///< The sum of energy in kWh, that is fed into the grid, starting from the beginning of the current simulation run
        double sum_of_grid_demand_kWh;    ///< The sum of energy in kWh, that is taken from the grid, starting from the beginning of the current simulation run
        double sum_of_rem_pow_costs_EUR;  ///< The sum of the costs for the (remaining) demanded energy starting from the beginning of the current simulation run up to the current step
        double sum_of_saved_pow_costs_EUR;///< The sum of saved power costs, i.e., the sum avoided grid demand starting from the beginning of the current simulation run up to the current step
        double sum_of_feedin_revenue_EUR; ///< The sum of the costs for the demanded energy starting from the beginning of the current simulation run up to the current step
        double sum_of_emissions_cbgd_kg_CO2eq;///< The sum of emissions in kg CO2eq. caused by grid demand (thus _bgd_ in the variable name) starting from the beginning of the current simulation run up to the current step
        double sum_of_emissions_avoi_kg_CO2eq;///< The sum of avoided emissions in kg CO2eq. because no grid demand was required starting from the beginning of the current simulation run up to the current step
        // other variables that are valid from the beginning of the simulation run until the current time step
        float  peak_grid_demand_kW;             ///< The maximum of grid demand that occured during a time step
        // summation variables from the beginning of the currently simulated week until the current time step
        double sum_of_cweek_consumption_kWh;    ///< The sum of consumed energy in kWh starting from the beginning of the currently simulated week until the current time step
        double sum_of_cweek_self_cons_kWh;      ///< The sum of self-consumed energy in kWh starting from the beginning of the currently simulated week until the current time step
        double sum_of_cweek_mu_cons_kWh;        ///< The sum of energy consumed by measurement units from the beginning of the currently simulated week until the current time step
        double sum_of_cweek_feed_into_grid_kWh; ///< The sum of energy in kWh, that is fed into the grid, starting from the beginning of the currently simulated week until the current time step
        double sum_of_cweek_grid_demand_kWh;    ///< The sum of energy in kWh, that is taken from the grid, starting from the beginning of the currently simulated week until the current time step
        double sum_of_cweek_rem_pow_costs_EUR;  ///< The sum of the costs for the (remaining) demanded energy starting from the beginning of the currently simulated week until the current time step
        double sum_of_cweek_saved_pow_costs_EUR;///< The sum of saved power costs, i.e., the sum avoided grid demand starting from the beginning of the currently simulated week until the current time step
        double sum_of_cweek_feedin_revenue_EUR; ///< The sum of the costs for the demanded energy starting from the beginning of the currently simulated week until the current time step
        double sum_of_cweek_emissions_cbgd_kg_CO2eq;///< The sum of emissions in kg CO2eq. caused by grid demand (thus _bgd_ in the variable name) starting from the beginning of the currently simulated week until the current time step
        double sum_of_cweek_emissions_avoi_kg_CO2eq;///< The sum of avoided emissions in kg CO2eq. because no grid demand was required starting from the beginning of the currently simulated week until the current time step
        // other variables that are valid from the beginning of the currently simulated week until the current time step
        float  cweek_peak_grid_demand_kW;       ///< The maximum of grid demand that occured during a time step in the current week
        //bool   create_history_output; ///< True, if a history output should be created for this control unit.
        //
        float current_load_vSM_kW; ///< Current load at the virtual smart meter
        float self_produced_load_kW; ///< Load [in kW] that is produced by the PV / taken from Battery / El. vehicle AND directly consumed by the measurement units
        //
        bool is_expandable_with_pv_hp_cache; ///< Cached value saying is this unit expandable with a (roof-top) PV installation or a heat pump (it requires geo data for this!)
        bool is_expandable_with_pv_hp_cache_computed; ///< Boolean variable if cache has been computed
        //
        // static list of CUs
        static bool st__cu_list_init;
        static unsigned long st__n_CUs;
        static unsigned long st__new_CU_position;
        static ControlUnit** st__cu_list;
        //static std::map<unsigned long, ControlUnit*> location_to_cu_map;
    public:
        static const std::string MetricsStringHeaderAnnual; ///< The header for the output string produced by `ControlUnit::get_metrics_string_annual()`
        static const std::string MetricsStringHeaderWeekly; ///< The header for the output string produced by `ControlUnit::get_metrics_string_weekly_wr()`
};


/*!
 *  The measurement unit represents an existing unit, which is measured by an existing
 *  smart meter where we have real measured data for.
 *  If there exist additional components, like PV, in reality, an instance of this class knows this.
 */
class MeasurementUnit {
    public:
        static MeasurementUnit* InstantiateNewMeasurementUnit(size_t meUID, size_t unitID, std::string * meterPointName, size_t locID, 
                bool has_demand, bool has_feedin, bool has_pv_resid, bool has_pv_opens,
                bool has_bess,   bool has_hp,     bool has_wind,     bool has_evchst,
                bool has_chp) {
                    return new MeasurementUnit(meUID, unitID, meterPointName, locID, has_demand, has_feedin, has_pv_resid, has_pv_opens, has_bess, has_hp, has_wind, has_evchst, has_chp);
                }
    private:
        // initialization and destruction
        MeasurementUnit(size_t meUID, size_t unitID, std::string * meterPointName, size_t locID, 
                        bool has_demand, bool has_feedin, bool has_pv_resid, bool has_pv_opens,
                        bool has_bess,   bool has_hp,     bool has_wind,     bool has_evchst,
                        bool has_chp);
    public:
        ~MeasurementUnit();
        bool load_data(const char * filepath);
        bool has_demand() { return rsm_has_demand; }
        bool has_feedin() { return rsm_has_feedin; }
        bool has_pv()     { return rsm_with_pv_residential || rsm_with_pv_open_space; }
        bool has_pv_residential() { return rsm_with_pv_residential; }
        bool has_pv_open_space()  { return rsm_with_pv_open_space; }
        bool has_bs()     { return rsm_with_bess;}
        bool has_hp()     { return rsm_with_hp;  }
        bool has_evchst() { return rsm_with_evchst;  }
        bool has_chp()    { return rsm_with_chp; }
        int  get_expansion_combination() { return expansion_combination; }
        inline const std::string * get_meterPointName() const;
        inline unsigned long get_meUID() const;
        inline unsigned long get_locationID() const;
        // for simulation runs
        bool compute_next_value(unsigned long ts);
        float get_current_ts_rsm_value() { return current_load_rsm_kW; }
        //
        // Class (i.e. static) functions
        // 1. Initializers and destructors
        static void InitializeStaticVariables(unsigned long n_MUs);
        static void VacuumInstancesAndStaticVariables();
        static size_t GetNumberOfInstances() {return st__n_MUs;}
        //
        // 2. Class getter methods
    private:
        // constant member variables (other languages might call this 'final')
        const unsigned long meUID;
        ControlUnit *const higher_level_cu;
        const std::string *const meterPointName;
        const unsigned long locationID;
        // member variables that can change over time
        float current_load_rsm_kW;
        bool rsm_has_demand; ///< RSM stands for Real Smart Meter
        bool rsm_has_feedin;
        bool rsm_with_pv_residential;
        bool rsm_with_pv_open_space;
        bool rsm_with_bess;
        bool rsm_with_hp;
        bool rsm_with_evchst; ///< True, if an EV charging station is connected
        bool rsm_with_wind;   ///< True, if a wind farm is connected
        bool rsm_with_chp;
        int expansion_combination;
        // member variables storing the data
        bool   data_loaded;
        int*   data_timestepID;
        float* data_value_demand;
        float* data_value_feedin;
        //char*  data_status_demand;
        //char*  data_status_feedin;
        //
        // static list of MUs
        static bool st__mu_list_init;
        static size_t st__n_MUs;
        static size_t st__new_MU_position;
        static MeasurementUnit** st__mu_list;
};



enum OpenSpacePVOrWindType {
    PV,
    Wind
};

class OpenSpacePVOrWind {
    public:
        OpenSpacePVOrWind(float kWp, OpenSpacePVOrWindType type);
        float get_current_feedin_kW() { return current_feedin_kW; }
        // for simulation runs
        bool compute_next_value(unsigned long ts);
    private:
        // constant member variables
        const float kWp;
        const float* profile_data; ///< Reference to the array of size Global::get_n_timesteps(), where the profile is stored. Should be global::wind_profile or global::pv_profile
        // members that might change during the time
        float current_feedin_kW;
};

#endif


/*
 * units.h
 *
 * It contains the definition of all units. A unit is
 * a compositions of individual components, that might
 * has more complex control rules or the additionl data
 * input.
 *
 */

#ifndef UNITS_H
#define UNITS_H

#include <string>
#include <list>
#include <map>

// The following classes are defined in this header file:
class Substation;
class ControlUnit;
class MeasurementUnit;
class OpenSpacePVOrWind;

#include "global.h"
#include "components.h"
#include "optimization_unit_general.hpp"
#include "output.h"
#include "worker_threads.hpp"


/*!
 * This class represents a substation.
 * One or more control units are connected to one instance of this class.
 */
class Substation {
    public:
        /*!
         * Instantiates a new substation object.
         * Returns false, if the ID is already defined.
         */
        static bool InstantiateNewSubstation(unsigned long public_id, std::string* name);
    private:
        Substation(unsigned long internal_id, unsigned long public_id, std::string* name);
    public:
        ~Substation();
        // getter methods
        unsigned long get_internal_id() const { return internal_id; } ///< Returns the internal ID of the substation
        unsigned long get_id()         const  { return public_id;   } ///< Returns the ID of the substation as defined in the system structure database
        const std::string * get_name() const { return name; } ///< Returns the name of the substation
        float get_station_load()       const { return station_load;    } ///< Returns the current load at the substation in kW
        float get_residential_load()   const { return resident_load;   } ///< Returns the current load at the substation in kW, generated by residential control units only
        float get_residential_demand() const { return resident_demand; } ///< Returns the demand of residential control units at this substation in kW
        // modifiers bevore simulation start
        void add_unit(ControlUnit* unit);
        // methods for simulation run
        void  calc_load();
        const std::list<ControlUnit*>* get_connected_units() { return connected_units; } ///< Return the list of connected units (as read only list)
        //
        // static functions
        // 1. Initializers and destructors
        static void InitializeStaticVariables(unsigned long n_substations);
        static void VacuumInstancesAndStaticVariables();
        // 2. getter functions
        static Substation* GetInstancePublicID(unsigned long public_id); ///< Returns the instance with a given public_id
        static Substation* GetInstanceInternalID(unsigned long internal_id) { return st__substation_list[internal_id]; } ///< Returns the instance with a given public_id
        static const std::vector<Substation*>& GetArrayOfInstances() { return st__substation_list; } ///< Returns the std::vector of all substation instances. The objects itself are mutable, but the vector is const.
        static size_t GetNumberOfInstances() {return st__n_substations;}
    private:
        // constant member variables (other languages might call this 'final')
        const unsigned long internal_id; ///< The internal ID, must be sequentially
        const unsigned long public_id; ///< The public ID as given in the system structure database
        const std::string *const name;
        // member variables that can change over time
        std::list<ControlUnit*>* connected_units;
        float station_load;    ///< Load of the station
        float resident_load;   ///< Load only of residential buildings
        float resident_demand; ///< Residential load, only demand
        //
        // static list of substations
        //static bool st__substation_list_init;
        static unsigned long st__n_substations;
        //static unsigned long st__new_substation_position;
        static std::vector<Substation*> st__substation_list;
        static std::map<unsigned long, unsigned long> public_to_internal_id;
};


/*!
 * This class represents a control unit (i.e. a private house or a small company).
 * As the name suggests it is the place where a central control is located (if any, or a rulebased otherwise).
 * All simulatively added components are added in this control unit.
 * It holds a set (at least one) of measurement units.
 */
class ControlUnit {
    public:
        /*!
         * Instantiates a new control unit.
         * Returns false, if the unitID is already defined.
         */
        static bool InstantiateNewControlUnit(unsigned long unitID, unsigned long substation_id, unsigned long locationID, bool residential);
    private:
        ControlUnit(unsigned long internalID, unsigned long publicID, unsigned long substation_id, unsigned long locationID, bool residential);
    public:
        ~ControlUnit();
        void add_unit(MeasurementUnit* unit);
        bool has_electricity_demand();
        bool has_pv();
        bool has_bs();
        bool has_hp();
        bool has_cs(); ///< Checks, if the unit has an EV charging station connected (in data or simulated)
        bool has_chp();
        bool has_bs_sim_added();
        bool is_expandable_with_pv(); ///< Is a simulated PV installation addable (yes, if geodata is available). This function uses caching.
        bool is_expandable_with_hp(); ///< Is a simulated heat pump addable (yes, if geodata or gas consumption data is available). This function uses caching.
        bool is_residential() { return residential; } ///< Is this unit a residential unit?
        bool heat_demand_given_in_data(); ///< Returns true, if the heat demand for this location is given in the input data
        int  get_exp_combi_bit_repr();
        int  get_exp_combi_bit_repr_from_MUs();
        int  get_exp_combi_bit_repr_sim_added();
        float get_current_load_vSMeter_kW() { return current_load_vSM_kW; }
        size_t get_n_MUs()     { return connected_units->size(); } // returns the number of MUs, that are connected to the given control unit
        size_t get_internal_id() const { return internal_id; }   ///< Returns the (consecutive) internal ID of the control unit
        size_t get_unitID()      const { return unitID; }        ///< returns the unit ID of this control unit as given in the system structure database
        size_t get_location_id() const { return locationID; }    ///< Returns the location ID of the control unit
        double get_mean_annual_MU_el_demand_kWh() const; ///< Returns the mean electricity demand in kWh of all connected MUs over all available years
        float get_sim_comp_pv_kWp(); // returns the kWp of the PV-component that is added for the simulation, returns 0 if there is no added PV component
        float get_sim_comp_bs_P_kW(); // returns the power in kW of the battery storage component that is added for the simulation, returns 0 if there is no added battery
        float get_sim_comp_bs_E_kWh(); // returns the capacity in kWh of the battery storage component that is added for the simulation, returns 0 if there is no added battery
        float get_annual_heat_demand_th_kWh();  ///< Returns the annual heat demand in (thermal) kWh of all attachted buildings
        float get_annual_hp_el_cons_kWh();      ///< Returns the annual HP electricity consumption of a heat pump in kWh, if it would be added simulatively (regardless whether it is added or not)
        float get_sim_comp_cs_max_P_kW() const; ///< Returns the maximum available charging power of the simulatively added charging station (if the station is enabled; otherwise it returns 0)
        size_t get_sim_comp_cs_n_EVs() const;   ///< Returns the number of connected EVs if the charging station component is enabled, otherwise 0 is returned.
        size_t get_sim_comp_cs_possible_n_EVs() const; ///< Returns the number of EVs that would be connected to the charging station component, if it would be enablede
        double  get_SSR(); ///< Returns the SSR of the CU from the start of the simulation run until the time of function call; most usefull at the end of a simulation run
        double  get_SCR(); ///< Returns the SCR of the CU from the start of the simulation run until the time of function call; most usefull at the end of a simulation run
        double  get_NPV(); ///< Returns the net present value (NPV) of the CU from the start of the simulation run until the time of function call; most usefull at the end of a simulation run
        string* get_metrics_string_annual(); // call this function only if simulation run is finished! It will the compute sums of flows,SSC,SSR and output this as a string
        string* get_metrics_string_weekly_wr(unsigned long week_number); // This function outputs the weekly metrics AND resets the internal weekly counters!
        string* get_pv_section_string(); // This function returns a string containing information about the sections of the sim. added PV component. If no PV component is added, it returns an empty string.
        // public members
        bool is_sim_expanded; ///< Puplicly accessible member, weather the control unit is expanded or not (required for SAC Planning). This flag has no internal effect inside the class.
        // modifiers
        void add_exp_pv();
        void add_exp_bs(); ///< Adds a simulated battery storage. Mind: MUST be called after ControlUnit::add_exp_hp() if it is called to ensure proper storage sizing for all configurations.
        void add_exp_hp();
        void add_exp_cs(); ///< Activates / enables the EV charging station at the control unit
        void add_ev(unsigned long carID); ///< Adds an EV to the charging station (regardless if the charging station is enabled or not)
        void set_output_object(CUOutput* output_obj);
        void set_exp_pv_params_A(float kWp_static); ///< Set the kWp of expanded PV installations in the case of static kWp computation per section
        void set_exp_pv_params_B(float kWp_per_m2, float min_kWp, float max_kWp); ///< Set the kWp of expanded PV installations in the case of dynamic kWp computation per section
        void set_exp_bs_maxE_kWh(float value);
        void set_exp_bs_maxP_kW (float value);
        void set_exp_bs_E_P_ratio(float value); //< Set the E:P-ratio for simulatively added BS components to @param value
        void remove_sim_added_pv(); ///< Removes a simulatively added PV installation
        void remove_sim_added_bs(); ///< Removes a simulatively added battery storage
        void remove_sim_added_components(); ///< Remove all components that are added simulatively
        void reset_internal_state(); ///< Resets the internal state of the object, without removing added components
        // for simulation runs
        bool compute_next_value(unsigned long ts, unsigned int dayOfWeek_l, unsigned int hourOfDay_l); ///< Computes the value for the (next) time step. The additional parameters dayOfWeek and hourOfDay are only required for passing them to the Charging Station. Mind: Both values are "left-aligned", i.e., they are the labels for the start of the current time step (in contrast to global::time_localtime_str)
        //
        // static functions
        // 1. Initializers and destructors
        static void InitializeStaticVariables(unsigned long n_CUs);
        static void VacuumInstancesAndStaticVariables();
        // 2. getter functions
        static ControlUnit* GetInstancePublicID(unsigned long unitID);   ///< Returns instance with a public unitID. Returns NULL, if unitID is out of the given range
        static ControlUnit* GetInstancePublicIDWE(unsigned long unitID); ///< Returns instance with a public unitID. Throws an error, if untiID is not defined
        static ControlUnit* GetInstanceInternalID(unsigned long internalID) {return st__cu_list[internalID];} ///< Returns the instance with a given internal ID without checking of the boundaries
        //static ControlUnit* GetInstanceAtLocationID(unsigned long locationID);
        static const std::vector<ControlUnit*>& GetArrayOfInstances() {return st__cu_list;}
        static size_t GetNumberOfInstances() {return st__n_CUs;}
        static size_t GetNumberOfCUsWithSimCompPV();        ///< Returns the number of control units that hold a simulatively added PV installation
        static size_t GetNumberOfCUsWithSimCompHP();        ///< Returns the number of control units that hold a simulatively added heat pump
        static size_t GetNumberOfCUsWithSimCompEV();        ///< Returns the number of control units that hold a simulatively added (private) EV charging stations
        static double GetAllSimCompBatteriesCharge_kWh();   ///< Returns the charge of all simulatively added battery storage systems at the current ts
        static double GetAllSimCompBatteriesCapacity_kWh(); ///< Returns the capacity of all simulatively added battery storage systems
        // 3. modifiers for all created objects
        static void ResetAllInternalStates();
        static void RemoveAllSimAddedComponents(); ///< Removes all simulatively added components from all control units
        static void ChangeControlHorizonInTS(unsigned int new_horizon); ///< Sets the optimization horizon (if another value is whished than given by Global::get_control_horizon_in_ts()). See also `ControlUnit::change_control_horizon_in_ts()`.
    protected:
        void change_control_horizon_in_ts(unsigned int new_horizon); ///< Sets the optimization horizon (if another value is whished than given by Global::get_control_horizon_in_ts()). This is protected, as the default vector used for the optimization-based control stretegies must be updated, too.
    private:
        // constant member variables (other languages might call this 'final')
        const unsigned long internal_id; ///< The internal ID of the control unit, must be sequentially
        const unsigned long unitID; ///< The public ID as given in the system structure database
        Substation *const higher_level_subst;
        const unsigned long locationID;
        const bool residential; ///< is this control unit representing a residential unit?
        // member variables that can change over time
        std::list<MeasurementUnit*>* connected_units;
        bool has_sim_pv; ///< boolean variable that states if a PV installation is simulatively added
        bool has_sim_bs; ///< boolean variable that states if a battery storage is simulatively added
        bool has_sim_hp; ///< boolean variable that states if a heap pump is simulatively added
        bool has_sim_cs; ///< boolean variable that states if an EV charging station is simulatively added
        ComponentPV* sim_comp_pv; ///< Reference to the simulated PV-Component (if it exists)
        ComponentBS* sim_comp_bs; ///< Reference to the simulated battery storage component (if it exists)
        ComponentHP* sim_comp_hp; ///< Reference to the simulated Heat Pump Component (if it exists)
        ComponentCS* sim_comp_cs; ///< Reference to the simulated EV charging station Component (if it exists)
        CUOutput*    output_obj;
        // summation variables from the beginning of the simulation run until the current time step
        double sum_of_consumption_kWh;    ///< The sum of consumed energy in kWh starting from the beginning of the current simulation run
        double sum_of_self_cons_kWh;      ///< The sum of self-consumed energy in kWh starting from the beginning of the current simulation run
        double sum_of_mu_cons_kWh;        ///< The sum of energy consumed by measurement units from the beginning fo the simulation until the current step
        double sum_of_feed_into_grid_kWh; ///< The sum of energy in kWh, that is fed into the grid, starting from the beginning of the current simulation run
        double sum_of_grid_demand_kWh;    ///< The sum of energy in kWh, that is taken from the grid, starting from the beginning of the current simulation run
        double sum_of_rem_pow_costs_EUR;  ///< The sum of the costs for the (remaining) demanded energy starting from the beginning of the current simulation run up to the current step
        double sum_of_saved_pow_costs_EUR;///< The sum of saved power costs, i.e., the sum avoided grid demand starting from the beginning of the current simulation run up to the current step
        double sum_of_feedin_revenue_EUR; ///< The sum of the costs for the demanded energy starting from the beginning of the current simulation run up to the current step
        double sum_of_emissions_cbgd_kg_CO2eq;///< The sum of emissions in kg CO2eq. caused by grid demand (thus _bgd_ in the variable name) starting from the beginning of the current simulation run up to the current step
        double sum_of_emissions_avoi_kg_CO2eq;///< The sum of avoided emissions in kg CO2eq. because no grid demand was required starting from the beginning of the current simulation run up to the current step
        // other variables that are valid from the beginning of the simulation run until the current time step
        float  peak_grid_demand_kW;             ///< The maximum of grid demand that occured during a time step
        // summation variables from the beginning of the currently simulated week until the current time step
        double sum_of_cweek_consumption_kWh;    ///< The sum of consumed energy in kWh starting from the beginning of the currently simulated week until the current time step
        double sum_of_cweek_self_cons_kWh;      ///< The sum of self-consumed energy in kWh starting from the beginning of the currently simulated week until the current time step
        double sum_of_cweek_mu_cons_kWh;        ///< The sum of energy consumed by measurement units from the beginning of the currently simulated week until the current time step
        double sum_of_cweek_feed_into_grid_kWh; ///< The sum of energy in kWh, that is fed into the grid, starting from the beginning of the currently simulated week until the current time step
        double sum_of_cweek_grid_demand_kWh;    ///< The sum of energy in kWh, that is taken from the grid, starting from the beginning of the currently simulated week until the current time step
        double sum_of_cweek_rem_pow_costs_EUR;  ///< The sum of the costs for the (remaining) demanded energy starting from the beginning of the currently simulated week until the current time step
        double sum_of_cweek_saved_pow_costs_EUR;///< The sum of saved power costs, i.e., the sum avoided grid demand starting from the beginning of the currently simulated week until the current time step
        double sum_of_cweek_feedin_revenue_EUR; ///< The sum of the costs for the demanded energy starting from the beginning of the currently simulated week until the current time step
        double sum_of_cweek_emissions_cbgd_kg_CO2eq;///< The sum of emissions in kg CO2eq. caused by grid demand (thus _bgd_ in the variable name) starting from the beginning of the currently simulated week until the current time step
        double sum_of_cweek_emissions_avoi_kg_CO2eq;///< The sum of avoided emissions in kg CO2eq. because no grid demand was required starting from the beginning of the currently simulated week until the current time step
        // other variables that are valid from the beginning of the currently simulated week until the current time step
        float  cweek_peak_grid_demand_kW;       ///< The maximum of grid demand that occured during a time step in the current week
        // caches for optimization
        CUOptimization::OptimalControlCommandsOverHorizon optimization_result_cache; ///< The interal cache of the optimization result
        //bool   create_history_output; ///< True, if a history output should be created for this control unit.
        //
        float current_load_vSM_kW; ///< Current load at the virtual smart meter
        float self_produced_load_kW; ///< Load [in kW] that is produced by the PV / taken from Battery / El. vehicle AND directly consumed by the measurement units
        //
        bool is_expandable_with_pv_cache; ///< Cached value saying is this unit expandable with a (roof-top) PV installation or a heat pump (it requires geo data for this!)
        bool is_expandable_with_pv_cache_computed; ///< Boolean variable if cache has been computed
        bool is_expandable_with_hp_cache; ///< Cached value saying is this unit expandable with a (roof-top) PV installation or a heat pump (it requires geo data for this!)
        bool is_expandable_with_hp_cache_computed; ///< Boolean variable if cache has been computed
        //
        // Variables required for multi-threading
        // CUControllerWorkerThread is getting full access to the member variables of this class
        // Required only for the member variable worker_thread
        friend class CUControllerWorkerThread;
        CUControllerWorkerThread* worker_thread; ///< The working thead to which this substation is attached. The reference is NULL if unattached or no multithreading is used.
        //
        // static list of CUs
        static unsigned long st__n_CUs;
        static std::vector<ControlUnit*> st__cu_list;
        static std::map<unsigned long, unsigned long> public_to_internal_id;
        static std::vector<double>* st__empty_vector_for_time_horizon; ///< An vector of 0.0 with the size of the current control horizon
        //static std::map<unsigned long, ControlUnit*> location_to_cu_map;
    public:
        static const std::string MetricsStringHeaderAnnual; ///< The header for the output string produced by `ControlUnit::get_metrics_string_annual()`
        static const std::string MetricsStringHeaderWeekly; ///< The header for the output string produced by `ControlUnit::get_metrics_string_weekly_wr()`
};


/*!
 *  The measurement unit represents an existing unit, which is measured by an existing
 *  smart meter where we have real measured data for.
 *  If there exist additional components, like PV, in reality, an instance of this class knows this.
 */
class MeasurementUnit {
    public:
        /*!
         * Instantiates a new measurement unit.
         * Returns false, if the meUID is already defined.
         */
        static bool InstantiateNewMeasurementUnit(size_t meUID, size_t public_unitID, std::string * meterPointName, size_t locID, 
                bool has_demand, bool has_feedin, bool has_pv_resid, bool has_pv_opens,
                bool has_bess,   bool has_hp,     bool has_wind,     bool has_evchst,
                bool has_chp, const std::string& data_source_path);
    private:
        // initialization and destruction
        MeasurementUnit(size_t internalID, size_t meUID, size_t public_unitID, std::string * meterPointName, size_t locID, 
                        bool has_demand, bool has_feedin, bool has_pv_resid, bool has_pv_opens,
                        bool has_bess,   bool has_hp,     bool has_wind,     bool has_evchst,
                        bool has_chp, const std::string& data_source_path);
    public:
        ~MeasurementUnit();
        const std::string * get_meterPointName() const { return meterPointName; } ///< Returns the name of the meter point
        unsigned long get_internal_id()          const { return internal_id; }    ///< Returns the (consecutive) internal ID of the measurement unit
        unsigned long get_meUID()                const { return meUID; }          ///< Returns the ID as given in the system structe database
        unsigned long get_locationID()           const { return locationID; }     ///< Returns the ID of the location
        bool load_data(); ///< Load the data as given by the member variable data_source_path. Returns false if an error happend during file loading.
        bool has_demand() const { return rsm_has_demand; }
        bool has_feedin() const { return rsm_has_feedin; }
        bool has_pv()     const { return rsm_with_pv_residential || rsm_with_pv_open_space; }
        bool has_pv_residential() const { return rsm_with_pv_residential; }
        bool has_pv_open_space()  const { return rsm_with_pv_open_space; }
        bool has_bs()     const { return rsm_with_bess;}
        bool has_hp()     const { return rsm_with_hp;  }
        bool has_evchst() const { return rsm_with_evchst;  }
        bool has_chp()    const { return rsm_with_chp; }
        int  get_expansion_combination() const  { return expansion_combination; }
        // for simulation runs
        double get_total_demand_kWh() const; ///< Returns the total demand of the measurement unit over the complete time span of data
        bool compute_next_value(unsigned long ts);
        float get_current_ts_rsm_value() const { return current_load_rsm_kW; }
        /**
         * Returns the load at the smart meter at a given time step in kW.
         * If there is no data available, it returns 0.0.
         * This method does not change the object.
         * @param ts: The time step for which the load should be computed
         */
        float get_rsm_value_at_ts(unsigned long ts) const;
        //
        // Class (i.e. static) functions
        // 1. Initializers and destructors
        static void InitializeStaticVariables(unsigned long n_MUs);
        static void VacuumInstancesAndStaticVariables();
        static size_t GetNumberOfInstances() {return st__n_MUs;}
        static bool LoadDataForAllInstances(); ///< Loads the data for all created instances
        //
        // 2. Class getter methods
        static MeasurementUnit* GetInstancePublicID(unsigned long meUID); ///< Returns instance with public id meUID (or NULL, if the ID is not available)
    private:
        // constant member variables (other languages might call this 'final')
        const unsigned long internal_id; ///< The internal ID, must be sequentially
        const unsigned long meUID;  ///< The public ID as given in the system structure database
        ControlUnit *const higher_level_cu;
        const std::string *const meterPointName;
        const unsigned long locationID;
        const std::string data_source_path;
        // member variables that can change over time
        float current_load_rsm_kW;
        bool rsm_has_demand; ///< RSM stands for Real Smart Meter
        bool rsm_has_feedin;
        bool rsm_with_pv_residential;
        bool rsm_with_pv_open_space;
        bool rsm_with_bess;
        bool rsm_with_hp;
        bool rsm_with_evchst; ///< True, if an EV charging station is connected
        bool rsm_with_wind;   ///< True, if a wind farm is connected
        bool rsm_with_chp;
        int expansion_combination;
        // member variables storing the data
        bool   data_loaded;
        int*   data_timestepID;
        float* data_value_demand;
        float* data_value_feedin;
        //char*  data_status_demand;
        //char*  data_status_feedin;
        //
        // static list of MUs
        static size_t st__n_MUs;
        static std::vector<MeasurementUnit*> st__mu_list;
        static std::map<unsigned long, unsigned long> public_to_internal_id;
};



enum OpenSpacePVOrWindType {
    PV,
    Wind
};

class OpenSpacePVOrWind {
    public:
        OpenSpacePVOrWind(float kWp, OpenSpacePVOrWindType type);
        float get_current_feedin_kW() { return current_feedin_kW; }
        // for simulation runs
        bool compute_next_value(unsigned long ts);
    private:
        // constant member variables
        const float kWp;
        const float* profile_data; ///< Reference to the array of size Global::get_n_timesteps(), where the profile is stored. Should be global::wind_profile or global::pv_profile
        // members that might change during the time
        float current_feedin_kW;
};

#endif

